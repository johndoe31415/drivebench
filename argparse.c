/*
 *   This file was AUTO-GENERATED by pypgmopts.
 *
 *   https://github.com/johndoe31415/pypgmopts
 *
 *   Do not edit it by hand, your changes will be overwritten.
 *
 *   Generated at: 2023-01-15 17:13:08
 */

#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <stdarg.h>
#include <string.h>
#include "argparse.h"

static enum argparse_option_t last_parsed_option;
static char last_error_message[256];
static const char *option_texts[] = {
	[ARG_SEQUENTIAL_CHUNK_SIZE] = "-c / --sequential-chunk-size",
	[ARG_SEQUENTIAL_SAMPLES] = "-S / --sequential-samples",
	[ARG_SEQUENTIAL_ITERATIONS] = "-i / --sequential-iterations",
	[ARG_THREAD_COUNT] = "-t / --thread-count",
	[ARG_READ_COUNTS_TOTAL] = "-r / --read-counts-total",
	[ARG_READ_4K_BUCKETS] = "--read-4k-buckets",
	[ARG_SEED] = "-s / --seed",
	[ARG_NO_SEQUENTIAL] = "--no-sequential",
	[ARG_NO_SINGLE_THREADED_4K] = "--no-single-threaded-4k",
	[ARG_NO_MULTI_THREADED_4K] = "--no-multi-threaded-4k",
	[ARG_JSON_OUTPUT] = "-j / --json-output",
	[ARG_VERBOSE] = "-v / --verbose",
	[ARG_DEVICE] = "device",
};

enum argparse_option_internal_t {
	ARG_SEQUENTIAL_CHUNK_SIZE_SHORT = 'c',
	ARG_SEQUENTIAL_SAMPLES_SHORT = 'S',
	ARG_SEQUENTIAL_ITERATIONS_SHORT = 'i',
	ARG_THREAD_COUNT_SHORT = 't',
	ARG_READ_COUNTS_TOTAL_SHORT = 'r',
	ARG_SEED_SHORT = 's',
	ARG_JSON_OUTPUT_SHORT = 'j',
	ARG_VERBOSE_SHORT = 'v',
	ARG_SEQUENTIAL_CHUNK_SIZE_LONG = 1000,
	ARG_SEQUENTIAL_SAMPLES_LONG = 1001,
	ARG_SEQUENTIAL_ITERATIONS_LONG = 1002,
	ARG_THREAD_COUNT_LONG = 1003,
	ARG_READ_COUNTS_TOTAL_LONG = 1004,
	ARG_READ_4K_BUCKETS_LONG = 1005,
	ARG_SEED_LONG = 1006,
	ARG_NO_SEQUENTIAL_LONG = 1007,
	ARG_NO_SINGLE_THREADED_4K_LONG = 1008,
	ARG_NO_MULTI_THREADED_4K_LONG = 1009,
	ARG_JSON_OUTPUT_LONG = 1010,
	ARG_VERBOSE_LONG = 1011,
	ARG_DEVICE_LONG = 1012,
};

static void errmsg_callback(const char *errmsg, ...) {
	va_list ap;
	va_start(ap, errmsg);
	vsnprintf(last_error_message, sizeof(last_error_message), errmsg, ap);
	va_end(ap);
}

static void errmsg_option_callback(enum argparse_option_t error_option, const char *errmsg, ...) {
	last_parsed_option = error_option;

	va_list ap;
	va_start(ap, errmsg);
	vsnprintf(last_error_message, sizeof(last_error_message), errmsg, ap);
	va_end(ap);
}

bool argparse_parse(int argc, char **argv, argparse_callback_t argument_callback, argparse_plausibilization_callback_t plausibilization_callback) {
	last_parsed_option = ARGPARSE_NO_OPTION;
	const char *short_options = "c:S:i:t:r:s:j:v";
	struct option long_options[] = {
		{ "sequential-chunk-size",            required_argument, 0, ARG_SEQUENTIAL_CHUNK_SIZE_LONG },
		{ "sequential-samples",               required_argument, 0, ARG_SEQUENTIAL_SAMPLES_LONG },
		{ "sequential-iterations",            required_argument, 0, ARG_SEQUENTIAL_ITERATIONS_LONG },
		{ "thread-count",                     required_argument, 0, ARG_THREAD_COUNT_LONG },
		{ "read-counts-total",                required_argument, 0, ARG_READ_COUNTS_TOTAL_LONG },
		{ "read-4k-buckets",                  required_argument, 0, ARG_READ_4K_BUCKETS_LONG },
		{ "seed",                             required_argument, 0, ARG_SEED_LONG },
		{ "no-sequential",                    no_argument, 0, ARG_NO_SEQUENTIAL_LONG },
		{ "no-single-threaded-4k",            no_argument, 0, ARG_NO_SINGLE_THREADED_4K_LONG },
		{ "no-multi-threaded-4k",             no_argument, 0, ARG_NO_MULTI_THREADED_4K_LONG },
		{ "json-output",                      required_argument, 0, ARG_JSON_OUTPUT_LONG },
		{ "verbose",                          no_argument, 0, ARG_VERBOSE_LONG },
		{ "device",                           required_argument, 0, ARG_DEVICE_LONG },
		{ 0 }
	};

	while (true) {
		int optval = getopt_long(argc, argv, short_options, long_options, NULL);
		if (optval == -1) {
			break;
		}
		last_error_message[0] = 0;
		enum argparse_option_internal_t arg = (enum argparse_option_internal_t)optval;
		switch (arg) {
			case ARG_SEQUENTIAL_CHUNK_SIZE_SHORT:
			case ARG_SEQUENTIAL_CHUNK_SIZE_LONG:
				last_parsed_option = ARG_SEQUENTIAL_CHUNK_SIZE;
				if (!argument_callback(ARG_SEQUENTIAL_CHUNK_SIZE, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_SEQUENTIAL_SAMPLES_SHORT:
			case ARG_SEQUENTIAL_SAMPLES_LONG:
				last_parsed_option = ARG_SEQUENTIAL_SAMPLES;
				if (!argument_callback(ARG_SEQUENTIAL_SAMPLES, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_SEQUENTIAL_ITERATIONS_SHORT:
			case ARG_SEQUENTIAL_ITERATIONS_LONG:
				last_parsed_option = ARG_SEQUENTIAL_ITERATIONS;
				if (!argument_callback(ARG_SEQUENTIAL_ITERATIONS, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_THREAD_COUNT_SHORT:
			case ARG_THREAD_COUNT_LONG:
				last_parsed_option = ARG_THREAD_COUNT;
				if (!argument_callback(ARG_THREAD_COUNT, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_READ_COUNTS_TOTAL_SHORT:
			case ARG_READ_COUNTS_TOTAL_LONG:
				last_parsed_option = ARG_READ_COUNTS_TOTAL;
				if (!argument_callback(ARG_READ_COUNTS_TOTAL, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_READ_4K_BUCKETS_LONG:
				last_parsed_option = ARG_READ_4K_BUCKETS;
				if (!argument_callback(ARG_READ_4K_BUCKETS, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_SEED_SHORT:
			case ARG_SEED_LONG:
				last_parsed_option = ARG_SEED;
				if (!argument_callback(ARG_SEED, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_NO_SEQUENTIAL_LONG:
				last_parsed_option = ARG_NO_SEQUENTIAL;
				if (!argument_callback(ARG_NO_SEQUENTIAL, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_NO_SINGLE_THREADED_4K_LONG:
				last_parsed_option = ARG_NO_SINGLE_THREADED_4K;
				if (!argument_callback(ARG_NO_SINGLE_THREADED_4K, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_NO_MULTI_THREADED_4K_LONG:
				last_parsed_option = ARG_NO_MULTI_THREADED_4K;
				if (!argument_callback(ARG_NO_MULTI_THREADED_4K, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_JSON_OUTPUT_SHORT:
			case ARG_JSON_OUTPUT_LONG:
				last_parsed_option = ARG_JSON_OUTPUT;
				if (!argument_callback(ARG_JSON_OUTPUT, optarg, errmsg_callback)) {
					return false;
				}
				break;

			case ARG_VERBOSE_SHORT:
			case ARG_VERBOSE_LONG:
				last_parsed_option = ARG_VERBOSE;
				if (!argument_callback(ARG_VERBOSE, optarg, errmsg_callback)) {
					return false;
				}
				break;

			default:
				last_parsed_option = ARGPARSE_NO_OPTION;
				errmsg_callback("unrecognized option supplied");
				return false;
		}
	}

	const int positional_argument_cnt = argc - optind;
	last_parsed_option = ARGPARSE_POSITIONAL_ARG;
	if (positional_argument_cnt != 1) {
		errmsg_callback("expected exactly 1 positional argument, but %d given.", positional_argument_cnt);
		return false;
	}

	int positional_index = optind;
	last_parsed_option = ARG_DEVICE;
	if (!argument_callback(ARG_DEVICE, argv[positional_index++], errmsg_callback)) {
		return false;
	}

	if (plausibilization_callback) {
		if (!plausibilization_callback(errmsg_option_callback)) {
			return false;
		}
	}
	return true;
}

void argparse_show_syntax(void) {
	fprintf(stderr, "usage: drivebench [-c MiB] [-S count] [-i count] [-t count] [-r count] [--read-4k-buckets count]\n");
	fprintf(stderr, "                  [-s string] [--no-sequential] [--no-single-threaded-4k] [--no-multi-threaded-4k]\n");
	fprintf(stderr, "                  [-j filename] [-v]\n");
	fprintf(stderr, "                  path\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "Measure performance of a hard drive.\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "positional arguments:\n");
	fprintf(stderr, "  path                  Device of hard drive to benchmark.\n");
	fprintf(stderr, "\n");
	fprintf(stderr, "options:\n");
	fprintf(stderr, "  -c MiB, --sequential-chunk-size MiB\n");
	fprintf(stderr, "                        For sequential reads, defines the chunk size in MiB. Defaults to 128 MiB.\n");
	fprintf(stderr, "  -S count, --sequential-samples count\n");
	fprintf(stderr, "                        For sequential reads, defines the number of data points to sample within the\n");
	fprintf(stderr, "                        disk. Defaults to 100.\n");
	fprintf(stderr, "  -i count, --sequential-iterations count\n");
	fprintf(stderr, "                        Number of times to repeat sequential read test. Defaults to 3.\n");
	fprintf(stderr, "  -t count, --thread-count count\n");
	fprintf(stderr, "                        For concurrent random access, defines the number of threads to use. Defaults\n");
	fprintf(stderr, "                        to 64.\n");
	fprintf(stderr, "  -r count, --read-counts-total count\n");
	fprintf(stderr, "                        For random access time measurements, defines the number of 4 kiB blocks to\n");
	fprintf(stderr, "                        read total, divided evenly among threads. Defaults to 1280000.\n");
	fprintf(stderr, "  --read-4k-buckets count\n");
	fprintf(stderr, "                        Number of buckets to use for grouping 4k random reads. Defaults to 64.\n");
	fprintf(stderr, "  -s string, --seed string\n");
	fprintf(stderr, "                        Initializes the PRNG which creates the pseudo-random access pattern to this\n");
	fprintf(stderr, "                        specific seed. Randomized by default. Can be any string.\n");
	fprintf(stderr, "  --no-sequential       Do not measure sequential thread performance.\n");
	fprintf(stderr, "  --no-single-threaded-4k\n");
	fprintf(stderr, "                        Do not measure single-threaded 4k access latency.\n");
	fprintf(stderr, "  --no-multi-threaded-4k\n");
	fprintf(stderr, "                        Do not measure multi-threaded 4k access latency.\n");
	fprintf(stderr, "  -j filename, --json-output filename\n");
	fprintf(stderr, "                        Write results into this JSON file.\n");
	fprintf(stderr, "  -v, --verbose         Increase verbosity. Can be specified multiple times.\n");
}

void argparse_parse_or_quit(int argc, char **argv, argparse_callback_t argument_callback, argparse_plausibilization_callback_t plausibilization_callback) {
	if (!argparse_parse(argc, argv, argument_callback, plausibilization_callback)) {
		if (last_parsed_option > ARGPARSE_POSITIONAL_ARG) {
			if (last_error_message[0]) {
				fprintf(stderr, "drivebench: error parsing argument %s -- %s\n", option_texts[last_parsed_option], last_error_message);
			} else {
				fprintf(stderr, "drivebench: error parsing argument %s -- no details available\n", option_texts[last_parsed_option]);
			}
		} else if (last_parsed_option == ARGPARSE_POSITIONAL_ARG) {
			fprintf(stderr, "drivebench: error parsing optional arguments -- %s\n", last_error_message);
		}
		argparse_show_syntax();
		exit(EXIT_FAILURE);
	}
}

#ifdef __ARGPARSE_MAIN__
/*   gcc -D __ARGPARSE_MAIN__ -O2 -Wall -o argparse argparse.c
*/

static const char *option_enum_to_str(enum argparse_option_t option) {
	switch (option) {
		case ARG_SEQUENTIAL_CHUNK_SIZE: return "ARG_SEQUENTIAL_CHUNK_SIZE";
		case ARG_SEQUENTIAL_SAMPLES: return "ARG_SEQUENTIAL_SAMPLES";
		case ARG_SEQUENTIAL_ITERATIONS: return "ARG_SEQUENTIAL_ITERATIONS";
		case ARG_THREAD_COUNT: return "ARG_THREAD_COUNT";
		case ARG_READ_COUNTS_TOTAL: return "ARG_READ_COUNTS_TOTAL";
		case ARG_READ_4K_BUCKETS: return "ARG_READ_4K_BUCKETS";
		case ARG_SEED: return "ARG_SEED";
		case ARG_NO_SEQUENTIAL: return "ARG_NO_SEQUENTIAL";
		case ARG_NO_SINGLE_THREADED_4K: return "ARG_NO_SINGLE_THREADED_4K";
		case ARG_NO_MULTI_THREADED_4K: return "ARG_NO_MULTI_THREADED_4K";
		case ARG_JSON_OUTPUT: return "ARG_JSON_OUTPUT";
		case ARG_VERBOSE: return "ARG_VERBOSE";
		case ARG_DEVICE: return "ARG_DEVICE";
	}
	return "UNKNOWN";
}

bool arg_print_callback(enum argparse_option_t option, const char *value, argparse_errmsg_callback_t errmsg_callback) {
	fprintf(stderr, "%s = \"%s\"\n", option_enum_to_str(option), value);
	return true;
}

int main(int argc, char **argv) {
	argparse_parse_or_quit(argc, argv, arg_print_callback, NULL);
	return 0;
}
#endif
